"""Script to parse the output file and raise bugs in Jira."""
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
import os
import jira
try:
    from jira import JIRAError
except:
    from jira.exceptions import JIRAError
import re
from lib import logger
from lib.Jiralib import Jiralib
from lib.IntConfig import notify
from lib.TestManagement import TestManagement
from lib.utilities import get_data_from_yaml


class ParseAndRaiseBug(object):
    """
    Parse Output xml generated by SUTAS framework and Raise bug in jira if \
    required
    """
    def __init__(self, url, username, password, project, affects_version,
                 env, watcher, pid, outputfile, robo_file=None, tc_management = None):
        """
            - **parameters**, **types**, **return** and **return types**::

                param url: url to connect jira and raise or update bug.
                param username: username to login to jira
                param password: password to login into jira
                param project: project name to raise bug in that project.
        """
        self.url = url
        self.username = username
        self.password = password
        self.project = project
        self.affects_version = affects_version
        self.env = env
        self.watcher = watcher
        self.tsid = pid
        self.robo_file = robo_file
        self.tc_management = tc_management
        self.outputfile = outputfile
        self.globfilepath = os.path.join(os.path.expanduser('~'), "global_conf.yaml")
        self.globdata = get_data_from_yaml(self.globfilepath)


    def validate_error(self, msg, tc_name):
        """
            Validates error for not raising a defect incase of invalid user inputs"

            - **parameters**, **types**, **return** and **return types**::

                :param msg: error msg of failed test case from output xml file.
                :param tc_name: name of the failed testcase
                :type msg: string
                :type tc_name: string

        """
        msg1 = "hardware requirement failed"
        msg2 = "software requirement failed"
        msg3 = "dependency tests failed"
        msg4 = "hence skipping the test case"
        msg_lower = msg.lower()
        if "No keyword with name".lower() in msg_lower:
            log_msg = "Not raising defect for tc '%s' since it is an import error.\n"%tc_name
            logger.warn(log_msg)
            notify.message(log_msg)
            return False
        elif msg_lower in ['connectionerror:', 'max retries exceeded with url']:
            log_msg = "Not raising defect for tc %s since it is a connection error.\n"%tc_name
            logger.warn(log_msg)
            notify.message(log_msg)
            return False
        elif re.search(r"expected\s\d\sarguments, \sgot\s\d", msg):
            key_word = re.search(r"\'(.*)\'", msg).group(1)
            log_msg = "Not raising defect for tc '%s' since user did not \
                provide required arguments for keyword %s.\n"% (tc_name, key_word)
            logger.warn(log_msg)
            notify.message(log_msg)
            return False
        elif "Already_Exist" in msg:
            log_msg = "Not raising defect for tc '%s' since user tried to \
                create already existing configurarion.\n" % tc_name
            logger.warn(log_msg)
            notify.message(log_msg)
            return False
        elif "Invalid_Argument" in msg:
            log_msg = "Not raising defect for tc '%s' since user provided \
                invalid arguments.\n" % tc_name
            logger.warn(log_msg)
            notify.message(log_msg)
            return False
        elif (msg1 in msg_lower) or (msg2 in msg_lower) or \
            (msg3 in msg_lower) or (msg4 in msg_lower):
            return False
        return True

    def validate_duplicate_issue(self, msg, obj, att, tc_name):
        """
            Find Duplicate issues based on Summaries comparison with error msg

                - **parameters**, **types**, **return** and **return types**::

                    :param msg: error msg of failed test case from the output xml file
                    :param obj: jira connection object
                    :param att: log file to be attached for the duplicate issue
        """

        summaries, issue_keys, issues = obj.get_summary(self.project)
        msg = msg.split()

        match = 0
        allfields = obj.conn.fields()
        namemap = {field['name']: field['id'] for field in allfields}
        def addwatchersforduplicateissue(obj, watcher):
            if watcher:
                users = self.watcher.split(",")
                for user in users:
                    try:
                        obj.conn.add_watcher(issue, user)
                    except Exception as err:
                        msg = '{} cannot be added as watcher'.format(user)
                        logger.warn(msg)

        for index, jira_msg in enumerate(summaries):
            no_match = []
            jira_msg = jira_msg.encode('utf-8').split()
            if len(jira_msg) == len(msg):
                for j in range(len(msg)):
                    if msg[j] != jira_msg[j]:
                        no_match.append([msg[j], jira_msg[j]])
                if len(no_match) == 0:
                    match += 1
                    issue_status = issues[index].fields.status.name.lower()
                    completed_statuses = ["done", "resolved", "completed",
                                          "qa-done", "merge-done", "passed",
                                          "merge-ready", "closed", "testing", "in review", "blocked"]
                    if issue_status not in completed_statuses:
                        issue = issues[index]
                        issue_status = issue.fields.status.name
                        Hitcount = issue.raw['fields'][namemap['HitCount']]
                        Hitcount = int(Hitcount) + 1
                        log_msg = "\n\nSimilar issue already exists with "\
                                  "id {} with status {} and error msg is "\
                                  "{}. So, Updating the Hit count to {}"\
                                  ".\n".format(issue_keys[index], issue_status, " ".join(msg), Hitcount)
                        issue = issues[index]
                        notify.message(log_msg)
                        self.update_hitcount(obj, issue,
                                             att, namemap, log_msg)
                        addwatchersforduplicateissue(obj, self.watcher)                


                    else:
                        try:
                            issue = issues[index]
                            fixed_versions = issues[index].raw['fields'][namemap['Fix Version/s']]
                            version = fixed_versions[0]
                            fix_version = version["name"]
                            if fix_version <= self.affects_version:
                                self.reopen_issue(obj, issue,
                                               issue_keys[index], att)
                                log_msg = "\n\nreopening the issue {} for the {}\n".format(issue_keys[index],tc_name)
                                self.update_hitcount(obj, issue, att, namemap, log_msg)
                                notify.message(log_msg)
                            else:
                                Hitcount = issue.raw['fields'][namemap['HitCount']]
                                Hitcount = int(Hitcount) + 1
                                log_msg = "\n\nSimilar issue already exists with "\
                                    " id {} with status {} and "\
                                    "your msg is "\
                                    "{}. So, Updating the Hit count to {}"\
                                    ".\n".format(issue_keys[index], issue_status, " ".join(msg), Hitcount)
                                notify.message(log_msg)
                                self.update_hitcount(obj, issue,
                                                     att, namemap, log_msg)
                                addwatchersforduplicateissue(obj, self.watcher)
                        except KeyError:
                            logger.warn("Fix version is Unknown in the defect\n")
                            issue = issues[index]
                        except IndexError:
                            logger.info('Fix version is None.')
                            issue = issues[index]
                            self.reopen_issue(obj, issue,
                                                  issue_keys[index], att)
                            text = "\n\nreopening the issue {} for the {}\n".format(issue_keys[index],tc_name)
                            logger.warn(text)
                            notify.message(text)                  

                    break
        if match:
            return issue
        else:
            return True

    def reopen_issue(self, obj, issue, issue_key, att):
        """
        Reopens an issue
        :param obj: Jiralib object
        :param issue: issue to be reopened
        :param issue_key: issue key value
        :param att: attachment to be added in the issue
        """
        for transition in obj.conn.transitions(issue):
            if 'open' or 'reopen' or 'reopened' in transition['name'].lower():
                obj.conn.transition_issue(
                    issue.key, str(transition['id']))
                #issue.fields.labels.append(u'reopen')
                #issue.update(fields={"labels": issue.fields.labels})
                comment = 'Reopened Bug and attached latest log'
                self.add_attachment_and_comment(obj, issue, att, comment)
                return issue
                break
        logger.warn("\nReopened {} issue \n".format(issue_key))

    def add_attachment_and_comment(self, obj, issue, att, comment):
        """
            Adds the attachment and comment to the issue

            - **parameters**, **types**, **return** and **return types**::

                :param obj: Jiralib object
                :param issue: issue id of jira issue to be updated
                :param att: Attachment to be updated in the issue
                :param comment: Message text to be updated in the issue
                :type obj: object
                :type issue: string
                :type att: string
                :type comment: string
        """
        try:
            obj.conn.add_attachment(issue=issue, attachment=att)
        except:
            if self.globdata.get('EnableTestArtifacts','no').lower() == 'yes':
                logslink = 'http://' + self.globdata['TestArtifact']['serverip'] + r'/sutas-logs/' + os.path.basename(os.environ['output_dir'] + '_Logs')
                obj.conn.add_simple_link(issue, {'url':logslink, 'title': os.path.basename(os.environ['output_dir']) + ' logs location in test artifact server'})
                obj.conn.add_comment(issue, 'logs location: ' + logslink)
            else:
                obj.conn.add_comment(issue, 'EnableTestArtifacts set to no, test artfact link not available')
        obj.conn.add_comment(issue, comment)

    def update_hitcount(self, obj, issue, att, namemap, log_msg):
        """
        Increments value of Hit count field and updates
            - **parameters**, **types**, **return** and **return types**::

                :param obj: Jiralib object
                :param issue: issue where HitCount field needs to be updated
                :param att: attachment to be added in the issue
                :param namemap: dictionary of customfields and its values in jira project
                :param log_msg: Message to be updated in the log
                :type obj: object
                :type issue: string
                :type att: string
                :type namemap: dictionary
                :type log_msg: string

        """
        logger.warn(log_msg)
        try:
            value = \
                issue.raw['fields'][namemap['HitCount']] + 1
            issue.update(
                fields={namemap['HitCount']: value})
            text = '\n\nHitCount increased to {}'.format(int(value)) + '\n'
            notify.message(text)

        except (KeyError, TypeError):
            logger.warn("\nHitCount field not found.")
        comment = "updated Hitcount and attached latest log"
        if not att is None:
            self.add_attachment_and_comment(obj, issue, att, comment)
    @staticmethod
    def chk_stats(outputfile):
        """
        Check Test statistics in the file output xml file
        Returns True if atleast 1 Test case in a Test Suite fails
        Parses the xml file and get error messages for each failed test case
        Form the summary and description with error messages.
        """
        out_file = os.path.join(outputfile, 'output.xml')
        if not os.path.isfile(out_file):
            raise Exception("Log file output.xml not generated since no tests are executed")
        tree = ET.ElementTree(file=out_file)
        root = tree.getroot()
        skipped = 0
        message = None
        msg1 = "hardware requirement failed"
        msg2 = "software requirement failed"
        msg3 = "dependency tests failed"
        msg4 = "hence skipping the test case"
        for test in root.iter("test"):
            for kw in test.iter("kw"):
                keyword = kw.attrib.get("library")
                if keyword:
                    keyword = keyword.lower()
                if not keyword == "teardown":
                    message = None
                    for msg in kw.iter("msg"):
                        if msg.attrib["level"] == "ERROR":
                            message = (msg.text).lower()
                            if (msg1 in message) or (msg2 in message) or \
                                                    (msg3 in message) or (msg4 in message):
                                skipped = skipped + 1
                            break
                    if not message:
                        for msg in kw.iter("msg"):
                            if msg.attrib["level"] == "FAIL":
                                message = (msg.text).lower()
                                if (msg1 in message) or \
                                    (msg2 in message) or (msg3 in message) or (msg4 in message):
                                    skipped = skipped + 1
                                break
        stats = root.find('statistics')
        if stats:
            childs = stats.find('suite').getchildren()
            for child in childs:
                if child.tag == 'stat':
                    items = list(child.items())
                    passed = int(child.attrib['pass'])
                    failed = int(child.attrib['fail']) - skipped
                    text = str(passed) + " Pass, " + str(skipped) + " Skip, " + str(failed) + " Fail\n"
                    os.environ['suiteresult'] = "{},{},{}".format(passed,skipped,failed)
                    pad = '*'*len(text)+'\n'
                    text = pad + text + pad
                    notify.message(text)
                    for item in items:
                        if item[0] == 'fail' and item[1] != '0':
                            return True
        return False

    def parse(self, suit_name, tc_name, kw_name, msg, att, raise_bugs):
        """
        Parse output xml file generated by SUTAS framework
        """
        msg = msg.replace('\n',' ')
        summ = tc_name + " failed with error " + msg
        summ = summ[0:250]
        desc = "Test suite name: %s \nTest case name"\
                    ": %s \nTest case failed while "\
                       "executing Keyword: %s \n Error msg"\
                       ": %s \n Please check attached log "\
                       "file for more informantion."\
                       % (suit_name, tc_name, kw_name, msg)
        if raise_bugs.lower() == 'yes':
            obj = Jiralib(self.url, self.username, self.password)
            issue = self.validate_duplicate_issue(msg, obj, att, tc_name)
            new_issue = issue
            if issue != True:
                issue = False
            if self.validate_error(msg, tc_name) and issue:
                try:
                    component, label = obj.get_fields_from_subtasks(\
                        self.project, tc_name, self.tsid)
                    new_issue = obj.raise_issue(self.project, self.affects_version, \
                                                self.env, summ, desc, self.watcher, \
                                                component, label, attachments=att)
                    text = str(new_issue.key) + \
                    "created for the test case " + tc_name
                    notify.message(text)
                    return new_issue
                except:
                    new_issue = obj.raise_issue(\
                        self.project, self.affects_version, \
                        self.env, summ, desc, self.watcher, attachments=att)
                    text = str(new_issue.key) + \
                    "created for the test case " + tc_name
                    notify.message(text)
                    return new_issue
            else:
                if not isinstance(new_issue, jira.resources.Issue):
                    new_issue = None
            return new_issue
